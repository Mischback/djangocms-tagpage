"""
@file   admin.py
@brief  To make this accessible in backend

DjangoCMS provides a special PageExtensionAdmin class, which nicely integrates
into the default Django administration backend.

This is necessary to provide the (automatically generated by Django Admin)
functionality to create and edit the extension, which is used by the
CMSToolbar of DjangoCMS.
"""

# Django imports
from django.core.exceptions import PermissionDenied
from django.contrib import admin, messages
from django.contrib.admin import helpers
from django.contrib.admin.util import get_deleted_objects, model_ngettext
from django.db import router
from django.template.response import TemplateResponse
from django.utils.encoding import force_text
from django.utils.translation import ugettext_lazy, ugettext as _
# DjangoCMS imports
from cms.extensions import PageExtensionAdmin
from cms.api import get_page_draft
# app imports
from .models import PageTags

class PageTagsAdmin(PageExtensionAdmin):
    """
    @class  PageTagsAdmin
    @brief  Provides the modified admin interface
    """
    list_display = ['extended_object']
    actions = ['custom_delete_selected']
    delete_selected_confirmation_template = 'djangocms_pagetags_delete_selected_confirmation.html'

    def get_actions(self, request):
        """
        @brief  Removes the default delete_selected() function
        """
        actions = super(PageTagsAdmin, self).get_actions(request)
        del actions['delete_selected']
        return actions

    def custom_delete_selected(modeladmin, request, queryset):
        """
        Default action which deletes the selected objects.

        This action first displays a confirmation page whichs shows all the
        deleteable objects, or, if the user has no permission one of the related
        childs (foreignkeys), a "permission denied" message.

        Next, it deletes all selected objects and redirects back to the change list.

        This function is directly taken from the Django core and modified to
        use the PageTags object's delete() method instead of the
        queryset.delete().

        Everything else is kept original to provide a consistent look and feel.
        """
        opts = modeladmin.model._meta
        app_label = opts.app_label

        # Check that the user has delete permission for the actual model
        if not modeladmin.has_delete_permission(request):
            raise PermissionDenied

        using = router.db_for_write(modeladmin.model)

        # Populate deletable_objects, a data structure of all related objects that
        # will also be deleted.
        deletable_objects, perms_needed, protected = get_deleted_objects(
            queryset, opts, request.user, modeladmin.admin_site, using)

        # The user has already confirmed the deletion.
        # Do the deletion and return a None to display the change list view again.
        if request.POST.get('post'):
            if perms_needed:
                raise PermissionDenied
            n = queryset.count()
            if n:
                for obj in queryset:
                    obj_display = force_text(obj)
                    modeladmin.log_deletion(request, obj, obj_display)
                    obj.delete()
                modeladmin.message_user(request, _("Successfully deleted %(count)d %(items)s.") % {
                    "count": n, "items": model_ngettext(modeladmin.opts, n)
                }, messages.SUCCESS)
            # Return None to display the change list page again.
            return None

        if len(queryset) == 1:
            objects_name = force_text(opts.verbose_name)
        else:
            objects_name = force_text(opts.verbose_name_plural)

        if perms_needed or protected:
            title = _("Cannot delete %(name)s") % {"name": objects_name}
        else:
            title = _("Are you sure?")

        context = {
            "title": title,
            "objects_name": objects_name,
            "deletable_objects": [deletable_objects],
            'queryset': queryset,
            "perms_lacking": perms_needed,
            "protected": protected,
            "opts": opts,
            "app_label": app_label,
            'action_checkbox_name': helpers.ACTION_CHECKBOX_NAME,
        }

        # Display the confirmation page
        return TemplateResponse(request, modeladmin.delete_selected_confirmation_template,
            context, current_app=modeladmin.admin_site.name)

    custom_delete_selected.short_description = 'Delete selected items'


    def is_draft_page(self, page):
        return page.extended_object.publisher_is_draft

# use this class as admin interface for PageTags
admin.site.register(PageTags, PageTagsAdmin)
